2.2 变量
--
变量 提供一个具名的、可供程序操作的存储空间。
C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。

2.2.1 变量定义

变量的基本形式是：首先是 类型说明符(type specifier),随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。列表中每个变量的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值：
int sum = 0, value, // sum、value和units_sold都是int
    units_sold = 0; // sum和units_sold初始值为0
Sales_item item;    // item的类型是Sales_item
// string 是一种库类型，表示一个可变长的字符序列
std::string book("0-201-78345-x"); // book 通过一个string 字面值初始化

book 的定义用到了库类型std::string，像iostream一样，string也是在命名空间std中定义的。

# 初始值
当对象在创建时获得了一个特定的值，我们说这个对象被 初始化(initialized)了。
用于初始化变量的值可以是任意复杂的表达式。
当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。
因此，在同一条定义语句时，可以用先定义的变量值去初始化定义后的其他变量。
```
//正确：price先被定义并赋值，随后被用于初始化discount
double price = 109.99, discount = price * 0.16;
//正确：调用函数applyDiscount，然后用函数的返回值初始化salePrice
double salePrice = applyDiscount(price, discount);
```
初始化不是赋值，初始化的含义时创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

# 列表初始化
C++定义了初始化的好几种不同形式。
```
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```
C++ 11 新标准 使得 花括号来初始变量得到全面应用。
当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在信息丢失的风险，则编译器将报错：
```
long double ld = 3.1415926536;
int a{ld}, b = {ld}; //错误：转换未执行，因为存在丢失信息的危险
int c(ld), d = ld;   //正确：转换执行，且确实丢失了部分值
```
# 默认初始化
  定义时未指定初值，变量被 默认初始化(default initialized),此时变量被赋予了"默认值"。
  如果内置类型变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体外的变量被初始化为0。 一种例外情况是，定义在函数体内部的内置变量将 不被初始化(uninitialized)。 一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类型将引发错误。
  每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由里类自己决定。如果类允许这种行为，它将决定对象的初始值是什么。
  绝大多数类都支持无须显式初始化而定义对象。这样的类提供了一个合适的默认值。(string在没有指定初值则生成一个空串)
```
std::string empty;  // empty 非显式地初始化为一个空串
Sales_item item;    // 被默认初始化的Sales_item对象
```
练习2.9
练习2.10

2.2.2 变量声明和定义的关系
  为了允许程序拆分为多个逻辑部分来编写，C++语言支持分离式编译(separate compliation)机制，该机制允许将程序分隔为若干个文件，每个文件可被独立编译。
  如果将程序分为多个文件，则需要有在文件间共享代码的方法。例如，一个文件的代码可能需要使用另一个文件中定义的变量。一个实际的例子是std::cout和std::cin,它们定义于标准库，却能被我们写的程序使用。
  为了支持分离式编译，C++语言将声明和定义区分开来。 **声明** (declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而 定义 (definition)负责创建与名字关联的实体。
  变量声明规定了变量的类型和名字，在这一点上定义与之相同。但除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。
  如果想声明一个变量而非定义它，就在变量名前添加关键字 extern ，而且不要显式地初始化变量：
```
extern int i;    // 声明i而非定义i；
int j;           // 声明并定义j；
```
任何包含了显式初始化的声明即为定义。我们能给由 extern 关键字标记的变量赋一个初值，但是这么做就抵消了 extern 的作用。extern 语句如果包含初始值就不再是声明，而变成定义了：
```
extern double pi = 3.1416; // 定义
```
在函数体内部，如果试图初始化一个由 extern 关键字标记的变量，将引发错误。

> 变量能且只能被定义一次，但是可以被多次声明。

声明和定义。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。
变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。

练习2.11

C++ 是一种静态类型(statically typed)语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为 类型检查(type checking).
对象的类型决定了对象所能参与的运算。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。
  程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型。

2.2.3 标识符
C++的标识符(identifier)由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感：
```
// 定义4个不同的int变量
int somename, someName, SomeName, SIMENAME;
```
变量命名规范

练习2.12

2.2.4 名字的作用域
程序中使用到的名字都会指向一个指定的实体：变量、函数、类型等。
如果一个名字出现在程序的不同位置，也可能指向的是不同实体。
  作用域(scope)是程序的一部分，在其中名字有特定的含义。C++语言中大多数作用域都以花括号分隔。
  同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。
```
#include <iostream>
int main()
{
    int sum = 0;
    // sum 用于存放从1到10的所有数的和
    for (int val = 1; val <= 10; ++val)
    {
        sum += val; //等价 sum = sum + val
    }
    std::cout << "Sum of 1 to 10 inclusive is "
              << sum << std::endl;
    return 0;
}
```
定义了三个名字 main sum 和 val , 同时使用了命名空间名字std,该空间提供2个名字cout和cin供程序使用。
main 定义于所有花括号之外，和其他大多数在函数体外的名字一样拥有 全局作用域(global scope)。一旦申明之后，全局作用域内的名字在整个程序的范围内都可使用。
名字sum在main函数所限定的作用域之内。从声明sum开始直到main都可访问，出了main函数所在的块之后就无法访问了，因此说sum拥有 块作用域(block scope)。
名字val定义于for语句内，在for语句内可以访问val，main函数的其他部分就不能访问它了。

嵌套的作用域
作用域能彼此包含，被包含(被嵌套)的作用域称为 内层作用域(inner scope),包含着别的作用域的作用域称为 外层作用域(outer scope).
作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字：
```
#include <iostream>
// 仅用于说明：函数内部不宜定义与全局变量同名的新变量
int reused = 42;
int main()
{
    int unique = 0; // unique 拥有块作用域
    // 输出 #1： 使用全局变量 reused ；输出42 0
    std::cout << reused << " " << unique << std::endl;
    int reused = 0; // 新建局部变量 reused，覆盖了全局变量 reused
    // 输出 #2： 使用局部变量 reused ；输出0 0
    std::cout << reused << " " << unique << std::endl;
    // 输出 #3： 显式地访问全局变量 reused ；输出42 0
    std::cout << ::reused << " " << unique << std::endl;
    return 0;
}
```
#1 局部变量 reused 定义之前，使用全局作用域中定义的 reused
#2 局部变量 reused 定义之后，此时局部变量 reused 正在作用域内(in scope)
#3 使用 域操作符 来覆盖默认的作用域规则。因为全局作用域本身没有名字，所以作用域操作符左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。
