第2章 变量和基本类型
==

数据类型

C++支持 - 基本内置类型(字符、整型、浮点数等)
        - 自定义数据类型
C++标准库 - 更复杂的数据类型(可变长字符串、向量等)

2.1 基本内置类型
--

算术类型(arithmetic type)     +   空类型 (void)
字符、整数型、布尔值、浮点数        不对应具体值，返回

2.1.1 算术类型
两类： 整型(integral type, 包括字符、布尔类型) 和 浮点型。

表2.1 C++算术类型
```
类型        含义           最小尺寸
bool        布尔类型       未定义
char        字符           8位
wchar_t     宽字符         16位
char16_t    Unicode字符    16位
char32_t    Unicode字符    32位
short       短整型         16位
int         整型           16位
long        长整形         32位
long long   长整形         64位
float       单精度浮点数   6位有效数字
double      双精度浮点数   10位有效数字
long double 扩展精度浮点数 10位有效数字
```
- 布尔类型 (bool) 取值 真(true) 或 假(false)
- 基本字符类型是 char，一个 char 的空间确保可以存放 机器 基本字符集 中 任意字符对应的数字值。(一个 char 的大小和一个机器字节一样。)
- 其他字符集用于扩展字符集，wchar_t、char16_t、char32_t、wchar_t 类型用于确保可以存放机器最大扩展字符集中的任意一个字符。
- 除字符和布尔类型外，其他整型用于表示(可能)不同尺寸的整数。
一个 int 至少和一个 short 一样大，
一个 long 至少和一个 int 一样大，
一个 long long 至少和一个 long 一样大。

>  1010110  0/1为比特。
大多数计算机以2的整数次幂个比特作为块来处理内存。
可寻址的最小内存块称为"字节(byte)",
存储的基本单元称为"字(word)"，通常由几个字节组成。
大多数字节由8比特构成，字则32或64比特构成，4或8字节。

- 浮点型可表示单精度、双精度和扩展精度值。float 以1个字(32比特)来表示，double 以2个字(64比特)来表示，long double 以3或4个字(96或128比特)来表示。

### 带符号类型和无符号类型 ###
除去布尔型和扩展的字符型之外，其他整型可以划分为 *带符号的(signed)* 和 *无符号的(unsigned)* 两种。

int、short、long long 带符号，加上 unsigned 得到无符号类型。
字符型分为3种，char、signed char、unsigned char。

2.1.1节练习
练习2.1 类型 int、long、long long 和 short 的区别是什么？无符号类型和带符号类型的区别是什么？float 和 double 的区别是什么？
> C++ guarantees short and int is at least 16 bits, long at least 32 bits, long long at least 64 bits.
> The signed can represent positive numbers, negtive numbers and zero, while unsigned can only represent numbers no less than zero.
练习2.2

2.1.2 类型转换
对象的类型定义了对象能包含的数据和能参与的运算。类型转换 convert 。
```
bool           b = 42  ;           // b为真 
int            i = b   ;           // i的值为1
               i = 3.14;           // i的值为3
double        pi = i   ;           // pi的值为3.0
unsigned char c  = -1  ;           // 假设char占8比特，c的值为255
signed   char c2 = 256 ;           // 假设char占8比特，c2的值是未定义的
```
当 赋值给无符号数一个超出范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。 8 比特大小的 unsigned char 可以表示 0 至 255 区间内的值，如果赋一个区间外的值，实际结果是该值对256取模后所得的余数。 -1 -> 255.

在程序某处使用了一种算术类型的值而其实所需的是另一种类型的值时，编译器同样会执行上述类型转换。
```
int i = 42;
if (i)     // if 条件的值将为true
    i = 0 ;
```
含有无符号类型的表达式
当一个算术表达式中既有无符号数又有 int 时，那个 int 值就会转换成无符号数。
把 int 转换为无符号数的过程和把 int 直接赋给无符号变量一样。
```
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl; // 输出-84
std::cout << u + i << std::endl; // 如果int占32位，输出4294967264
```
首先，把整数-42转换成无符号数，把负数转化为无符号数类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模。
从无符号数中减去一个值时，确保结果非负。
```
unsigned u1 = 42, u2 = 10;
std::cout << u1 - u2 << std::endl; // 正确：输出32
std::cout << u2 - u1 << std::endl; // 正确，不过，结果是取模后的值
```
无符号数不会小于0也关系到循环的写法。
```
for (int i = 10; i >= 0; --i)
    std::cout << i << std::endl;
/////////
//错误：变量u永远不会小于0，循环条件一直成立
for (unsigned int u = 10; u >= 0; --u)
    std::cout << u << std::endl;
```
解决办法.使用while代替for，可以在输出变量之前先减去1：
```
unsigned u = 11;
while (u > 0){
    -- u; // 先减1，这样最后一次迭代时就会输出0
    std::cout << u << std::endl;
}
```
练习2.3 
练习2.4

2.1.3 字面值常量
形如 42 的值被称作 字面值常量(literal)，一望而知。
# 整型和浮点型字面值
我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。
以0开头的整数代表八进制数，以 0x 或 0X 开头的代表十六进制数。

20   /* 十进制 */
024  /* 八进制 */
0x14 /* 十六进制 */

整型字面值具体的数据类型由它的值和符号决定。
默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。
十进制字面值的类型是 int、long、long long 尺寸中最小的那个，能容下当前值。
八进制十六进制字面值类型是能容纳其数值的 int、unsigned int、unsigned long、long long、unsigned long long 中的尺寸最小者。

浮点型字面值表现为一个小数或科学记数法表示的指数，其中指数部分用E或e标识：
3.14159   3.14159E0   0.   0e0   .001
默认，浮点型字面值是一个 double，我们可以使用表2.2的后缀表示其他浮点型。

# 字符和字符串字面值
由单引号括起来的一个字符称为 char 型字面值，
双引号括起来的零个或多个字符则构成字符串型字面值。
```
'a'            // 字符字面值
"Hello World!" // 字符串字面值
```
字符串字面值的类型实际上是由常量字符构成的数组(array),该类型将在3.5.4介绍。
编译器在每个字符串的结尾处添加一个空字符('\0'),因此，字符串字面值的实际长度要比它的内容多1.
例如，字面值'A'表示的就是单独的字符A,而字符串"A"则代表了一个字符的数组，该数组包含两个字符：一个是字母A，另一个是空字符。
两个字符串字面值位置紧邻而仅由空格、缩进和换行符分隔，则它们实际上是一个整体。
当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式：
```
// 分多行书写的字符串字面值
std::cout << "a really, really long string literal "
             "that spans two lines" << std::endl;
```

# 转义序列
有两类字符串程序员不能直接使用：
1.不可打印(nonprintable),如退格或其他控制字符，因为没有可视的图符；
2.有特殊含义的字符(单引号、双引号、问号、反斜线)。
需要使用 转义字符(escape sequence).
转义字符均以反斜线作为开始，C++规定的转义序列包括：

换行符     \n 横向制表符 \t 报警(响铃)符 \a
纵向制表符 \v 退格符     \b 双引号       \"
反斜线     \\ 问号       \? 单引号       \'  
回车符     \r 进纸符     \f
在程序中，上述转义序列被当作一个字符使用：
std::cout << '\n';       // 转到新一行
std::cout << "\tHi!\n";  // 输出一个制表符，输出"Hi!",转到新一行
我们也可以使用泛化的转义序列，形式时\x后紧跟1个或多个十六进制数字，或者\后紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。
假设使用Lantin-1字符集，以下为一些示例：
\7 (响铃)   \12  (换行符)  \40 (空格)
\0 (空字符) \115 (字符M)   \x4d(字符M)
我们可以像使用普通字符那样使用C++语言定义的转义序列；
std::cout << "Hi \x4dO\115!\n"; //输出Hi MOM!,转到新一行
std::cout << '\115' << '\n';    //输出M,转到新一行
如果反斜线\后面跟着的八进制数超过3个，前三个数字与\构成转义序列。
例如"\1234"表示2个字符，八进制数123对应的字符以及字符4.
相反，\x要用到后面跟着的所有数字，例如"\x1234"表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定。

# 指定字面值的类型
通过添加如表2.2中所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。
L'a'     // 宽字符型字面值，类型是wchar_t
u8"hi!"  // utf-8字符串字面值(utf-8用8位编码一个Unicode字符)
42ULL    // 无符号整型字面值，类型是unsigned long long
1E-3F    // 单精度浮点型字面值，类型是float
3.14159L // 扩展精度浮点型字面值，类型是long double

表2.2 指定字面值的类型

字符和字符串字面值
前缀    含义                        类型
u       Unicode16字符               char16_t
U       Unicode32字符               char32_t
L       宽字符                      wchar_t
u8      UTF-8(仅用于字符串字面常量) char

整型字面值
后缀            最小匹配类型
u或U            unsigned
l或L            long
ll或LL          long long

浮点型字面值
后缀            类型
f或F            float
l或L            long double

对于一个整型字面值来说，我们能分别指定它是否带符号以及占用多少空间。

# 布尔字面值和指针字面值
true 和 false 是布尔类型的字面值：
bool test = false;
nullptr 是指针字面值。(2.3.2节 更多关于指针。)

练习2.5
