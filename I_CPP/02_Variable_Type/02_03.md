2.3 复合类型
==

复合类型 (compound type)是指基于其他类型定义的类型。C++语言有几种复合类型。eg: 引用 指针。

定义复合类型的变量要比已经掌握的变量声明复杂很多。
一条简单的声明语句由一个数据类型和紧随其后的一个变量名列表组成。
== 一条声明语句由一个 基本数据类型(base type)和紧随其后的 声明符(declarator)列表组成。每个声明符命名了一个变量并指定该变量为基本数据类型有关的某种类型。
目前，我们所接触的声明语句中，声明符其实就是变量名，此时的变量的类型也就声明的基本数据类型。其实还可能有更复杂的声明符，它基于基本数据类型得到更复杂的类型，并把它指定给变量。

2.3.1 引用
--
> C++ 11中新增了一种引用：所谓的"右值引用(rvalue reference)"，这种引用主要用于内置类。 使用术语 "引用"时，指的是"左值引用(lvalue reference)"

引用(reference) 为对象起了另一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成&d的形式来定义引用类型。其中d是声明的变量名：
```
int ival = 1024;
int &refVal = ival;  // refVal 指向 ival(是ival的另一个名字)
int &refVal2;        // 报错：引用必须被初始化
```
一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值 绑定(bind)在一起。而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化。
> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另一个名字。

定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：
```
refVal = 2; // 把2赋给refVal指向的对象，此处即是赋给了ival
int ii = refVal; //与ii = ival 执行结果一样
```
为引用赋值，实际上时把值赋给了与引用绑定的对象。
获取引用的值，实际上是获取了与引用绑定的对象的值。
同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值：
```
// 正确：refVal3 绑定到了那个与refVal绑定的对象上，这里就是绑定在ival上
int &refVal3 = refVal;
// 利用与 refVal 绑定的对象的值初始化变量i
int i = refVal; // 正确： i被初始化为ival的值
```
引用的定义
允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号…&开头：
```
int i = 1024,   i2 = 2048; // i 和 i2 都是 int
int &r = i,     r2 = i2;   // r 是一个引用，与i绑定在一起，r2是int
int i3 = 1024, &ri = i3;   // i3是int，ri是一个引用，与i3绑定在一起
int &r3 = i3,  &r4 = i2;   // r3 和 r4 都是引用
```
除了两种特殊情况，其他所有引用的类型都要和与之绑定的对象严格匹配。
而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。
```
int &refVal4 = 10;   // 错误： 引用类型的初始值必须是一个对象
double dval = 3.14;
int &refVal5 = dval; // 错误： 此处引用类型的初始值必须是int型对象
```
2.3.1 练习
练习2.15
练习2.16
练习2.17

2.3.2 指针
--
  **指针**(pointer) 是指向(pointed to) 另一种类型的符合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针和引用相比又有很多不同点。
  - 其一：指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
  - 其二：指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

  定义指针的方法将变量声明符写成`*d`的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号`*`:
  ```
  int *ip1, *ip2;  // ip1 和 ip2 都是指向int型对象的指针
  double dp, *dp2; // dp2 是指向double型对象的指针，dp是double型对象
  ```
**获取对象的地址**
  指针存放某个对象的地址，要想获取该地址，需要使用**取地址符**(操作符&)
  ```
  int ival = 42;
  int *p = &ival; // p存放ival的地址，或者说p是指向变量ival的指针
  ```
  第二条语句把p定义为一个指向int的指针，随后初始化p令其指向名为ival的int对象。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。
  除了2.4.2(P56)/15.2.3(P534)两种例外情况，
  
**指针值**
  指针的值(即地址)应属下列4种状态之一：
  1.指向一个对象。
  2.指向紧邻对象所占空间的下一个位置。
  3.空指针，意味着指针没有指向任何位置。
  4.无效指针，也就是上述情况之外的其他值。
  试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。
  尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针(假定的)对象的行为不被允许。如果这样做了，后果也无法预计。

**利用指针访问对象**
  如果指针指向了一个对象，则允许使用**解引用符**(操作符*)来访问该对象：
  ```
  int ival = 42;
  int *p = &ival;  // p 存放着变量`ival`的地址，或者说p是指向变量`ival`的指针
  cout << *p;      // 由符号`*`得到指针p所指的对象，输出42
  ```
  对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：
  ```
  *p = 0;      // 由符号`*`得到指针p所指的对象，即可经由p为变量ival赋值
  cout << *p;  // 输出0
  ```

> 某些符号有多重含义
> 像&和*这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义：
```
int i = 42;
int &r = i;  // &紧随类型名出现，因此是声明的一部分，r是一个引用
int *p;      // *紧随类型名出现，因此是声明的一部分，p是一个指针
p = &i;      // &出现在表达式中，是一个取地址符
*p = i;      // *出现在表达式中，是一个解引用符
int &r2 = *p;// &是声明的一部分，*是一个解引用符
```
> 在声明语句中，&和*用于组成复合类型；在表达式中，它们的角色又转变成运算符。在不同场景下出现的虽然是同一个符号，但是由于含义截然不同，所以我们完全可以把它当作不同的符号来看待。

**空指针**
  空指针(null pointer)不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：
```
int *p1 = nullptr;   // 等价于 int *p1 = 0;
int *p2 = 0;         // 直接将p2初始化为字面常量0
// 首先需要 #include cstdlib
int *p3 = NULL;      // 等价于 int *p3 = 0;
```
  得到空指针最直接的方法就是用字面值 **nullptr**来初始化指针，这也是 C++11新标准刚刚引入的一种方法。nullptr 是一种特殊类型的字面常量，可以被转换成其他类型的指针类型。另一种办法就如对p2的定义一样，也可以通过将指针初始化为字面值0来初始化空指针。
  过去的程序还会用到一个名为NULL的 **预处理变量(preprocessor variable)**来给指针赋值，这个变量在头文件cstdlib中定义，值就是0。
  预处理器是运行于编译过程之前的一段程序。预处理变量不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预处理变量而无须在前面加上std::。
  当用到一个预处理变量时，预处理器会自动的将它替换为实际值，因此用NUL初始化指针和用0初始化指针是一样的。在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL。
  把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。
  ```
  int zero = 0;
  pi = zero;   // 错误，不能把int变量直接赋给指针
  ```
> 建议：初始化所有指针

**赋值和引用**
  指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是在访问它最初绑定的那个对象。
  指针和它存放的地址之间就没有这种限制了。和其他任何变量(只要不是引用)一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。
  ```
  int i = 42;
  int *pi = 0;    // pi被初始化，但没有指向任何对象
  int *pi2 = &i;  // pi2被初始化，存有i的地址
  int *pi3;       // 如果pi3定义于块内，则pi3的地址是无法确定的 

  pi3 = pi2;      // pi3和pi2指向同一个对象i
  pi2 = 0;        // 现在pi2不指向任何对象了
  ```  
  有时候想要搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易，最好的方法就是记住赋值永远改变的是等号左侧的对象。当写出如下语句时，
  ```
  pi = &ival;     // pi的值被改变，现在pi指向了ival
  ```
  意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。相反的，如果写出如下语句，
  ```
  *pi = 0;        // ival的值被改变，指针pi并没有改变
  ```
  则*pi(也就是指针pi指向的那个对象)发生改变。

**其他指针操作**
  只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算数值作为条件(参见2.1.2P32)遵循的规则类似，如果指针的值是0，条件取false；
  ```
  int ival = 1024;
  int *pi = 0;       // pi合法，是一个空指针
  int *pi2 = &ival;  // pi2是一个合法的指针，存放着ival的地址
  if (pi)            // pi的值是0，因此条件的值是false
      // ...
  if (pi2)           // pi2指向ival，因此它的值不是0，条件的值是true
      // ...
  ```
  任何非0指针对应的条件值都是true。
  对于两个类型相同的合法指针，可以用相等操作符(==)或不相等操作符(!=)来比较它们，比较的结果是布尔类型。如果两个指针存放的地址值相同，则它们相等：反之它们不相等。
  这里两个指针存放的地址值相同(两个指针相等)有三种可能：
  1.它们都为空、
  2.都指向同一个对象、
  3.都指向了同一对象的下一地址
  > 需要注意的是： 一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。
  因为上述操作要用到指针的值，所以不论是作为条件出现还是参与比较运算，都必须使用合法指针，使用非法指针作为条件或进行比较都会引发不可预计的后果。

**`void * 指针`**
  `void *`是一种特殊的指针类型，可用于存放任意对象的地址。一个`void *`指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解：
  ```
  double obj = 3.14, *pd = &obj;
                       // 正确，void *可能存放任意类型对象的地址
  void *pv = &obj;     // obj可以是任意类型的对象
  pv = pd;             // pv可以存放任意类型的指针
  ```
  利用`void *`指针能做的事儿比较有限：拿它和别的指针比较，作为函数的输入或输出，或者赋给另外一个`void *`指针。不能直接操作`void *`指针所指的对象，因为我们不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。
  概括来说，以`void *`的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。

2.3.2 节练习
练习 2.18
练习 2.19
练习 2.20
练习 2.21
练习 2.22
练习 2.23
练习 2.24

2.3.3 理解复合类型的声明
--
如前所述，变量的定义包括一个基本数据类型(base type)和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说，一条声明语句可能定义出不同类型的变量：
```
// i是一个int型的数，p是一个int型指针，r是一个int型引用
int i = 1024, *p = &i, &r = i;
```

**定义多个变量**
  经常有一种观点会误以为，在定义语句中，类型修饰符(\*或&)作用于本次定义的全部变量。造成这种错误看法的原因有很多，其中之一是我们可以把空格写在类型修饰符和变量名中间：
`int* p; // 合法但是容易产生误导`
  我们说这种写法可能产生误导是因为`int *`放在一起好像是这条语句中所有变量共同的类型一样。其实恰恰相反，
