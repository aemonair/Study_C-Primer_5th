2.3 复合类型
==

复合类型 (compound type)是指基于其他类型定义的类型。C++语言有几种复合类型。eg: 引用 指针。

定义复合类型的变量要比已经掌握的变量声明复杂很多。
一条简单的声明语句由一个数据类型和紧随其后的一个变量名列表组成。
== 一条声明语句由一个 基本数据类型(base type)和紧随其后的 声明符(declarator)列表组成。每个声明符命名了一个变量并指定该变量为基本数据类型有关的某种类型。
目前，我们所接触的声明语句中，声明符其实就是变量名，此时的变量的类型也就声明的基本数据类型。其实还可能有更复杂的声明符，它基于基本数据类型得到更复杂的类型，并把它指定给变量。

2.3.1 引用
--
> C++ 11中新增了一种引用：所谓的"右值引用(rvalue reference)"，这种引用主要用于内置类。 使用术语 "引用"时，指的是"左值引用(lvalue reference)"

引用(reference) 为对象起了另一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成&d的形式来定义引用类型。其中d是声明的变量名：
```
int ival = 1024;
int &refVal = ival;  // refVal 指向 ival(是ival的另一个名字)
int &refVal2;        // 报错：引用必须被初始化
```
一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值 绑定(bind)在一起。而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化。
> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另一个名字。

定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：
```
refVal = 2; // 把2赋给refVal指向的对象，此处即是赋给了ival
int ii = refVal; //与ii = ival 执行结果一样
```
为引用赋值，实际上时把值赋给了与引用绑定的对象。
获取引用的值，实际上是获取了与引用绑定的对象的值。
同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值：
```
// 正确：refVal3 绑定到了那个与refVal绑定的对象上，这里就是绑定在ival上
int &refVal3 = refVal;
// 利用与 refVal 绑定的对象的值初始化变量i
int i = refVal; // 正确： i被初始化为ival的值
```
引用的定义
允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号…&开头：
```
int i = 1024,   i2 = 2048; // i 和 i2 都是 int
int &r = i,     r2 = i2;   // r 是一个引用，与i绑定在一起，r2是int
int i3 = 1024, &ri = i3;   // i3是int，ri是一个引用，与i3绑定在一起
int &r3 = i3,  &r4 = i2;   // r3 和 r4 都是引用
```
除了两种特殊情况，其他所有引用的类型都要和与之绑定的对象严格匹配。
而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。
```
int &refVal4 = 10;   // 错误： 引用类型的初始值必须是一个对象
double dval = 3.14;
int &refVal5 = dval; // 错误： 此处引用类型的初始值必须是int型对象
```
2.3.1 练习
练习2.15
练习2.16
练习2.17

2.3.2 指针
--
  **指针**(pointer) 是指向(pointed to) 另一种类型的符合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针和引用相比又有很多不同点。
  - 其一：指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
  - 其二：指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

  定义指针的方法将变量声明符写成`*d`的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号`*`:
  ```
  int *ip1, *ip2;  // ip1 和 ip2 都是指向int型对象的指针
  double dp, *dp2; // dp2 是指向double型对象的指针，dp是double型对象
  ```
**获取对象的地址**
  指针存放某个对象的地址，要想获取该地址，需要使用**取地址符**(操作符&)
  ```
  int ival = 42;
  int *p = &ival; // p存放ival的地址，或者说p是指向变量ival的指针
  ```
  第二条语句把p定义为一个指向int的指针，随后初始化p令其指向名为ival的int对象。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。
  除了2.4.2(P56)/15.2.3(P534)两种例外情况，
  
